---
import { Picture } from 'astro:assets';

import Tag, { type TagColour } from './Tag.astro';
import Text from './Text.astro';

import fallbackImage from '../assets/images/flow.png';

export type Props = {
  title: string;
  description: string;
  tags?: string[];
  tagColour: TagColour;
  projectNumber: number;
  href: string;
  image?: ImageMetadata;
};

const { title, tagColour, description, projectNumber, href, tags, image } =
  Astro.props;

const hoverImage = image ?? fallbackImage;
---

<div data-project-tile-wrapper class="relative">
  <a
    data-project-tile
    class="flex w-full gap-x-[68px] border-2 px-[68px] py-4"
    href={href}
  >
    <div class="flex items-center">
      <Text type="h2">
        <span class="align-middle"> {projectNumber}. </span>
      </Text>
    </div>

    <div class="flex flex-col">
      <Text type="sh1" transition:name={`project-title-${title}`}>{title}</Text>

      <div class="flex gap-x-8 pt-2">
        {tags?.map((tag) => <Tag colour={tagColour}>{tag}</Tag>)}
      </div>
      <div class="pt-6">
        <Text type="body">
          {description}
        </Text>
      </div>
    </div>
  </a>

  <div
    data-hover-image
    class="pointer-events-none absolute top-0 right-0 z-40 hidden h-[440px] w-[640px] bg-black opacity-0 transition-opacity duration-300 ease-in-out"
  >
    <div class="h-full w-full border-2 bg-white p-20">
      <Picture
        src={hoverImage}
        formats={['avif', 'webp']}
        alt={`Preview of ${title} project`}
      />
    </div>
  </div>
</div>

<script>
  const VIEWPORT_BOTTOM_STANDOFF = 24;

  function setupHoverTooltips() {
    const wrappers = document.querySelectorAll('[data-project-tile-wrapper]');

    wrappers.forEach((wrapper) => {
      const tile = wrapper.querySelector('[data-project-tile]');
      const tooltip = wrapper.querySelector<HTMLElement>('[data-hover-image]');

      if (!tile || !tooltip) {
        return;
      }

      function updatePosition(tooltip: HTMLElement) {
        const wrapperRect = wrapper.getBoundingClientRect();
        const tooltipHeight = tooltip.offsetHeight;
        const naturalBottom = wrapperRect.top + tooltipHeight;

        const viewportLimit = window.innerHeight - VIEWPORT_BOTTOM_STANDOFF;

        if (naturalBottom > viewportLimit) {
          const overflow = naturalBottom - viewportLimit;
          tooltip.style.top = `-${overflow}px`;
        } else {
          tooltip.style.top = '0';
        }
      }

      tile.addEventListener('mouseenter', () => {
        tooltip.classList.remove('hidden');
        updatePosition(tooltip);

        requestAnimationFrame(() => {
          tooltip.classList.add('opacity-100');
          tooltip.classList.remove('opacity-0');
        });

        window.addEventListener('scroll', () => updatePosition(tooltip), {
          passive: true,
        });
      });

      tile.addEventListener('mouseleave', () => {
        window.removeEventListener('scroll', () => updatePosition(tooltip));

        tooltip.classList.add('opacity-0');
        tooltip.classList.remove('opacity-100');
        tooltip.addEventListener(
          'transitionend',
          () => {
            if (tooltip.classList.contains('opacity-0')) {
              tooltip.classList.add('hidden');
              tooltip.style.top = '0';
            }
          },
          { once: true },
        );
      });
    });
  }

  setupHoverTooltips();
  document.addEventListener('astro:page-load', setupHoverTooltips);
</script>

<style>
  div[data-hover-image] {
    box-shadow: 8px 8px 0px 0px rgba(0, 0, 0);
  }
</style>
